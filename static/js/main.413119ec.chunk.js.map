{"version":3,"sources":["mockData.js","api.js","actions/people.js","components/PeopleGrid.js","components/RemoteSubmitButton.js","components/ViewEditPerson.js","App.js","serviceWorker.js","reducers/people.js","store.js","index.js"],"names":["people","Object","toConsumableArray","Array","map","_","i","firstName","lastName","id","email","sleep","ms","Promise","resolve","setTimeout","FETCH_PEOPLE_REQUEST","FETCH_PEOPLE_SUCCESS","FETCH_PEOPLE_ERROR","PERSON_SELECTED","TOGGLE_EDITING","fetchPeople","dispatch","type","then","fetchPeopleSuccess","catch","error","fetchPeopleError","PeopleGrid","this","props","personSelected","_this","peopleCells","x","selected","react_default","a","createElement","Fragment","key","className","concat","onClick","e","personClicked","headerCells","React","Component","connect","state","_ref","submit","renderField","input","label","_ref$meta","meta","touched","editing","inputElement","assign","placeholder","value","RemoteSubmitForm","_this$props","handleSubmit","fieldProps","onSubmit","Field","name","component","toggleEditing","components_RemoteSubmitButton","connectedReduxForm","reduxForm","form","values","formProps","pristine","SubmissionError","_error","changedValues","initialValues","console","log","reject","person","find","p","idx","indexOf","newPerson","splice","ok","updatePerson","validate","errors","enableReinitialize","App","loadingPeople","components_PeopleGrid","ViewEditPerson","loading","Boolean","window","location","hostname","match","initialState","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","combineReducers","reducer","arguments","length","undefined","action","applyMiddleware","thunk","ReactDOM","render","es","store","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.413119ec.chunk.js","sourcesContent":["let people = [...new Array(5)].map((_, i) => ({\r\n  firstName: 'first'+i,\r\n  lastName: 'last'+i,\r\n  id: i,\r\n  email: i+'@test.com'\r\n}));\r\n\r\nexport { people };","import { people } from './mockData';\r\n\r\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\nfunction submit(values) {\r\n  return sleep(1000) // simulate server latency\r\n    .then();\r\n}\r\n\r\n\r\nfunction getAllPeople() {\r\n  return sleep(1000)\r\n    .then(\r\n      () => people\r\n    );\r\n}\r\n\r\nfunction updatePerson(values) {\r\n  return new Promise((resolve, reject) => {\r\n    let person = people.find(p => p.id === values.id),\r\n        idx = people.indexOf(person),\r\n        newPerson = Object.assign({}, person, values);\r\n    people.splice(idx, 1, newPerson);\r\n    return resolve({ok:true});\r\n  });\r\n}\r\nexport { submit, getAllPeople, updatePerson };\r\n","import { getAllPeople } from '../api';\r\n\r\nexport const FETCH_PEOPLE_REQUEST = 'FETCH_PEOPLE_REQUEST';\r\nexport const fetchPeopleRequest = function() {\r\n    return { type: FETCH_PEOPLE_REQUEST };\r\n};\r\n\r\nexport const FETCH_PEOPLE_SUCCESS = 'FETCH_PEOPLE_SUCCESS';\r\nexport const fetchPeopleSuccess = function(people) {\r\n  return { \r\n      type: FETCH_PEOPLE_SUCCESS, \r\n      people \r\n  };\r\n};\r\n\r\nexport const FETCH_PEOPLE_ERROR = 'FETCH_PEOPLE_ERROR';\r\nexport const fetchPeopleError = function(error) {\r\n  return {\r\n      type: FETCH_PEOPLE_ERROR,\r\n      error\r\n  }\r\n}\r\n\r\nexport const PERSON_SELECTED = 'PERSON_SELECTED';\r\nexport const personSelected = function(personId) {\r\n  return {\r\n    type: PERSON_SELECTED,\r\n    personSelected: personId\r\n  }\r\n}\r\n\r\nexport const TOGGLE_EDITING = 'TOGGLE_EDITING';\r\nexport const toggleEditing = function() {\r\n  return {\r\n    type: TOGGLE_EDITING\r\n  }\r\n}\r\n\r\nexport const fetchPeople = function() {\r\n  return function(dispatch) {\r\n      dispatch(fetchPeopleRequest());\r\n      return getAllPeople()\r\n          .then(people => dispatch(fetchPeopleSuccess(people)))\r\n          .catch(error => dispatch(fetchPeopleError(error)));\r\n  }\r\n};\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { personSelected } from \"../actions/people\";\r\n\r\nclass PeopleGrid extends React.Component {\r\n\r\n  personClicked(id) {\r\n    this.props.dispatch(personSelected(id));\r\n  }\r\n\r\n  render() {\r\n    const peopleCells = this.props.people.map((x, i) => {\r\n      /*\r\n        We use `selected` below to determine whether or not the current set of\r\n        cells corresponds to the currently selected person, and if so, add the \r\n        appropriate class so that we get the gray highlights on the whole row. \r\n      */\r\n      let selected = this.props.personSelected === i ? 'selected' : '';\r\n      return (\r\n        /*\r\n          A note on React.Fragment:\r\n          Normally, JSX elements should either consist of a single element,\r\n          or multiple elements wrapped in a single element at the top level.\r\n          Since we're returning siblings, and we don't want to wrap these divs\r\n          in another div (that would break the grid), we use React.Fragment.\r\n\r\n          See the docs for more on fragments:\r\n          https://reactjs.org/docs/fragments.html\r\n        */\r\n        <React.Fragment key={x.id}>\r\n          <div className={`cell id ${selected}`} onClick={e => this.personClicked(x.id)}>\r\n            {x.id}\r\n          </div>\r\n          <div className={`cell firstName ${selected}`} onClick={e => this.personClicked(x.id)}>\r\n            {x.firstName}\r\n          </div>\r\n          <div className={`cell lastName ${selected}`} onClick={e => this.personClicked(x.id)}>\r\n            {x.lastName}\r\n          </div>\r\n          <div className={`cell email ${selected}`} onClick={e => this.personClicked(x.id)}>\r\n            {x.email}\r\n          </div>\r\n        </React.Fragment>\r\n    )});\r\n    let headerCells = (\r\n        <React.Fragment>\r\n          <div className=\"cell header id\">id</div>\r\n          <div className=\"cell header firstName\">First Name</div>\r\n          <div className=\"cell header lastName\">Last Name</div>\r\n          <div className=\"cell header email\">Email</div>\r\n        </React.Fragment>\r\n      );\r\n    \r\n    return (\r\n        <div className=\"peoplegrid\">\r\n          {headerCells}\r\n          {peopleCells}\r\n        </div>\r\n    );    \r\n  }\r\n}\r\n\r\nfunction mapStateToProps(state) {\r\n  return {\r\n    people: state.people.people,\r\n    personSelected: state.people.personSelected\r\n  }\r\n};\r\n\r\nexport default connect(mapStateToProps)(PeopleGrid);","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { submit } from \"redux-form\";\r\n\r\n/*\r\n  This example demonstrates how a form may be submitted by dispatching \r\n  a SUBMIT action from an unrelated component or middleware.\r\n\r\n  The \"Submit\" button you see here is not connected to the form component\r\n  in any way; it only dispatches an action via Redux.\r\n\r\n  See docs:\r\n  https://redux-form.com/6.6.2/examples/remotesubmit/\r\n*/\r\n\r\nconst RemoteSubmitButton = ({ dispatch }) => (\r\n  <button\r\n    type=\"button\"\r\n    onClick={() => dispatch(submit(\"remoteSubmit\"))}\r\n    //                              ^^^^^^^^^^^^ name of the form\r\n  >\r\n    Submit\r\n  </button>\r\n);\r\n\r\nexport default connect()(RemoteSubmitButton);\r\n","import React from 'react'\r\nimport { Field, reduxForm, SubmissionError } from 'redux-form'\r\nimport { connect } from 'react-redux';\r\nimport { toggleEditing, fetchPeople } from \"../actions/people\";\r\nimport RemoteSubmitButton from './RemoteSubmitButton';\r\nimport { updatePerson } from '../api';\r\nconst renderField = ({ input, label, type, meta: { touched, error }, editing }) => {\r\n  /*\r\n   This function takes in all of the associated props for a Field,\r\n   and returns some JSX similar to a render function.\r\n\r\n   The `editing` key we are destructuring here is the result of passing `fieldProps`\r\n   to the `props` attribute when declaring the Field below.\r\n\r\n   This `editing` variable is what we then use to decide whether to\r\n   show an input or just the value (`input.value`).\r\n  */\r\n  let inputElement = <input {...input} placeholder={label} type={type}/>;\r\n  return (\r\n    <div>\r\n      <label>{label}</label>\r\n      <div>\r\n        { editing ? inputElement : input.value }\r\n        {/*\r\n          What's going on with this && stuff below?\r\n          It's \"short-circuiting\": \r\n          https://codeburst.io/javascript-short-circuit-conditionals-bbc13ac3e9eb\r\n\r\n          First `touched` is evaluted: If it is truthy, we continue and \r\n          evaluate `error`. If `error` is truthy, the last operand is evaluated,\r\n          and a <span> is always going to be truthy, so that is what the entire\r\n          expression evaluates to (kind of like a return value).\r\n        */}\r\n        { touched && error && <span>{ error }</span>}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nclass RemoteSubmitForm extends React.Component {\r\n  toggleEditing() {\r\n    this.props.dispatch(toggleEditing());\r\n  }\r\n\r\n  render() {\r\n    const { error, handleSubmit } = this.props;\r\n    let fieldProps = { editing: this.props.editing };\r\n    /*\r\n      We'll use this `fieldProps` object to pass the current `editing` state\r\n      into each field. It will be passed through the `props` attribute, \r\n      and redux-form will merge with the other props at the top level.\r\n    */\r\n    return (\r\n      <form onSubmit={handleSubmit} className=\"bordered\">\r\n        <Field name=\"firstName\" type=\"text\" component={renderField} label=\"First Name\" props={fieldProps}/>\r\n        <Field name=\"lastName\" type=\"text\" component={renderField} label=\"Last Name\" props={fieldProps}/>\r\n        <Field name=\"email\" type=\"email\" component={renderField} label=\"Email\" props={fieldProps}/>\r\n  \r\n        {error && <strong>{error}</strong>}\r\n\r\n        {this.props.personSelected !== null && (\r\n              <button type=\"button\" onClick={e => this.toggleEditing()}>\r\n                {this.props.editing ? \"Cancel\" : \"Edit\"}\r\n              </button>\r\n        )}\r\n\r\n        {this.props.editing && <RemoteSubmitButton />}\r\n\r\n      </form>\r\n    )\r\n  }\r\n}\r\n\r\nfunction validate(formProps) {  \r\n  const errors = {};\r\n  \r\n  if (!formProps.firstName) {\r\n    errors.firstName = 'Please enter a first name';\r\n  }\r\n  \r\n  if (!formProps.lastName) {\r\n    errors.lastName = 'Please enter a last name';\r\n  }\r\n  \r\n  if (!formProps.email) {\r\n    errors.email = 'Please enter an email';\r\n  }\r\n  \r\n  return errors;\r\n}\r\n\r\nfunction submit(values, dispatch, formProps) {\r\n  if (formProps.pristine)\r\n    throw new SubmissionError({_error: 'Nothing changed!'});\r\n  // We only want to send all of the fields that have changed,\r\n  // so we can send a PATCH with only the data we need. \r\n  // we can't get to the individual Fields' meta properties such as touched\r\n  // from here (afaik). Instead, we are going to compare values against\r\n  // formProps.initialValues, which will tell us which fields changed.\r\n  let changedValues = {id: values.id}; // We're going to need the id, and it isn't going to change\r\n  for (let key in values) {\r\n    if (formProps.initialValues[key] !== values[key])\r\n      changedValues[key] = values[key];\r\n  }\r\n  // Since we're comparing against initialValues here, we need to make sure\r\n  // subsequent submits are capturing an updated initialValues, and not comparing\r\n  // back to the original version. To accomplish this, we'll need to make sure\r\n  // that any successful submission dispatches a fetchPeople() action.\r\n  // That action changing the state should retrigger mapStateToProps\r\n  console.log('the changed fields are:', changedValues);\r\n  return updatePerson(changedValues)\r\n          .then(formProps.dispatch(fetchPeople()))\r\n}\r\n\r\nfunction mapStateToProps(state) {\r\n  let idx = state.people.personSelected,\r\n      person = idx !== null ? state.people.people[idx] : null;\r\n  return { \r\n    person, \r\n    initialValues: person, // props.initialValues is used by redux-form to populate the form\r\n                           // this works for us since the keys on our people objects\r\n                           // match up with the `name` attributes on our form Fields.\r\n    editing: state.people.editing,\r\n    personSelected: state.people.personSelected\r\n  };\r\n}\r\n\r\nconst connectedReduxForm = reduxForm({\r\n    form: 'remoteSubmit',  // a unique identifier for this form\r\n    onSubmit: submit,      // submit function must be passed to onSubmit\r\n    validate,\r\n    enableReinitialize: true // When set to true, the form will reinitialize every time the initialValues changes\r\n})(RemoteSubmitForm)\r\n\r\nexport default connect(mapStateToProps)(connectedReduxForm)\r\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport { connect } from \"react-redux\";\nimport { fetchPeople } from \"./actions/people\";\nimport PeopleGrid from \"./components/PeopleGrid\";\nimport ViewEditPerson from \"./components/ViewEditPerson\";\n\nclass App extends Component {\n  componentDidMount() {\n    // dispatch an action to fetch our data from\n    // the backend and populate the store\n    this.props.dispatch(fetchPeople());\n  }\n\n  render() {\n    if (!this.props.loadingPeople)\n      return (\n        <div className=\"flexcontainer\">\n          <PeopleGrid />\n          <ViewEditPerson />\n        </div>\n      );\n    else \n      return (\n        <div>\n          Loading data...\n        </div>\n      )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {\n    loadingPeople: state.people.loading\n  }\n}\n\nexport default connect(mapStateToProps)(App);\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import {\r\n  FETCH_PEOPLE_REQUEST,\r\n  FETCH_PEOPLE_SUCCESS,\r\n  FETCH_PEOPLE_ERROR,\r\n  PERSON_SELECTED,\r\n  TOGGLE_EDITING\r\n} from '../actions/people';\r\n\r\nconst initialState = {\r\n  people: [],\r\n  loading: true,\r\n  error: null,\r\n  personSelected: null,\r\n  editing: false\r\n};\r\n\r\nexport default function peopleReducer(state=initialState, action) {\r\n  /*\r\n    console.log(state);\r\n    console.log(action);\r\n  */\r\n  if (action.type === FETCH_PEOPLE_REQUEST) {\r\n      return Object.assign({}, state, {\r\n          loading: true,\r\n          error: null\r\n      });\r\n  }\r\n  if (action.type === FETCH_PEOPLE_SUCCESS) {\r\n      return Object.assign({}, state, {\r\n          loading: false,\r\n          error: null,\r\n          people: action.people\r\n      });\r\n  }\r\n  if (action.type === FETCH_PEOPLE_ERROR) {\r\n      return Object.assign({}, state, {\r\n          loading: false,\r\n          error: action.error,\r\n      });\r\n  }\r\n  if (action.type === PERSON_SELECTED) {\r\n    return Object.assign({}, state, {\r\n      personSelected: action.personSelected\r\n    });\r\n  }\r\n  if (action.type === TOGGLE_EDITING) {\r\n    return Object.assign({}, state, {\r\n      editing: !state.editing\r\n    });\r\n  }\r\n  return state;\r\n}\r\n","import { createStore, combineReducers, applyMiddleware, compose } from \"redux\";\r\nimport { reducer } from \"redux-form\";\r\nimport thunk from 'redux-thunk';\r\nimport peopleReducer from \"./reducers/people\";\r\n\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\n\r\nexport default createStore(\r\n  combineReducers({\r\n    form: reducer,\r\n    people: peopleReducer \r\n  }),\r\n  composeEnhancers(\r\n    applyMiddleware(thunk)\r\n  )\r\n);\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport store from './store';\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}